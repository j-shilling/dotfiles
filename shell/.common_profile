# -*- mode: sh -*-

export XDG_STATE_HOME="${HOME}/.local/var/lib"
export PASSWORD_STORE_DIR="${XDG_STATE_HOME}/password-store"
export EDITOR="emacsclient -a '' -c"
export BROWSER="nyxt"

if [ -d "/var/lib/flatpak/exports/share" ] ; then
    export XDG_DATA_DIRS="${XDG_DATA_DIRS}:/var/lib/flatpak/exports/share"
fi

if [ -d "${HOME}/.local/share/flatpak/exports/share" ] ; then
    export XDG_DATA_DIRS="${XDG_DATA_DIRS}:${HOME}/.local/share/flatpak/exports/share"
fi

# Maybe init GUIX
export GUIX_PROFILE="${HOME}/.guix-profile"
if [ -d $GUIX_PROFILE ] ; then
    source "$GUIX_PROFILE/etc/profile"
fi

export GUIX_PROFILE="${HOME}/.config/guix/current"
if [ -d $GUIX_PROFILE ] ; then
    source "$GUIX_PROFILE/etc/profile"
    export GUILE_LOAD_PATH="$HOME/.config/guix:$GUILE_LOAD_PATH"
fi

export GUILE_LOAD_PATH="$HOME/.config/guix:$GUILE_LOAD_PATH"

# Check for WSL
if type uname &> /dev/null && [[ "$(uname -r)" == *microsoft* ]] ; then
  export WSL_HOST_IP=$(awk '/nameserver/ { print $2 }' /etc/resolv.conf)
  export BROWSER="/mnt/c/Program Files/Google/Chrome/Application/chrome.exe"
#  export DISPLAY=$(awk '/nameserver / {print $2; exit}' /etc/resolv.conf 2>/dev/null):0
  export LIBGL_ALWAYS_INDIRECT=1

  if type guix &> /dev/null ; then
     wsl.exe -u root service guix-daemon status || wsl.exe -u root service guix-daemon start
  fi
fi

# General Env Vars
export PASSDIR="${HOME}/passwords"
if type gpgconf &> /dev/null ; then
  export SSH_AUTH_SOCK=$(gpgconf --list-dirs agent-ssh-socket)
fi

# Build Path Based on Which Dirs Exist
if [ -d "${HOME}/.local/bin" ] ; then
  export PATH="${HOME}/.local/bin:${PATH}"
fi

if [ -d "${HOME}/.emacs.d/bin" ] ; then
  export PATH="${HOME}/.emacs.d/bin:${PATH}"
fi

if [ -d "${HOME}/.cask/bin" ] ; then
  export PATH="${HOME}/.cask/bin:${PATH}"
fi

if [ -d "${HOME}/.eldev/bin" ] ; then
  export PATH="${HOME}/.eldev/bin:${PATH}"
fi

if [ -d "/var/lib/snapd/snap/bin" ] ; then
  export PATH="/var/lib/snapd/snap/bin:${PATH}"
fi

if [ -d "${HOME}/.dotnet/tools" ] ; then
  export PATH="${HOME}/.dotnet/tools:${PATH}"
fi

if [ -d "/opt/piavpn/bin" ] ; then
  export PATH="/opt/piavpn/bin:${PATH}"
fi

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

# Look for emacs-vterm install directory to find files that help with vterm
# integration in emacs

if [[ "${INSIDE_EMACS}" = 'vterm' ]] ; then
  if [[ -n "${EMACS_VTERM_PATH}" ]] && [[ -f "${EMACS_VTERM_PATH}/etc/emacs-vterm-zsh.sh" ]] ; then
    source "${EMACS_VTERM_PATH}/etc/emacs-vterm-zsh.sh"
  fi
fi

# This is needed to make this file cooperate with TRAMP
# mode
[ $TERM = "dumb" ] && unsetopt zle && PS1='$ '

alias sysu="systemctl --user"

if type lsd &> /dev/null ; then
    alias ls='lsd'
fi

alias ls='ls -p --color=auto'
alias grep='grep --color=auto'
