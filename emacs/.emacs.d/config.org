#+AUTHOR: Jake Shilling
#+LANG: en
#+STARTUP: overview
#+PROPERTY: header-args :cache yes :mkdirp yes :padline yes :tangle init.el

* Early Init
:PROPERTIES:
:header-args: :tangle early-init.el
:END:

#+begin_src emacs-lisp
  ;;; early-init.el -*- lexical-binding: t; -*-

  (setq gc-cons-threshold most-positive-fixnum)
  (add-hook 'after-init-hook
	    (lambda ()
	      (setq gc-cons-threshold (* 1025 10))))

  (setq package-enable-at-startup nil)

  (setq load-prefer-newer noninteractive)

  ;; Doom says this is faster than calling the corresponding functions. See
  ;; core-ui.el
  (push '(menu-bar-lines . 0)   default-frame-alist)
  (push '(tool-bar-lines . 0)   default-frame-alist)
  (push '(vertical-scroll-bars) default-frame-alist)

  (when (featurep 'native-compile)
    (setq native-comp-async-report-warnings-errors nil
	  native-comp-deferred-compilation t))

  ;;; early-init.el ends here
#+end_src

* Init
:PROPERTIES:
:header-args: :tangle init.el
:END:

** File Header
#+begin_src emacs-lisp
;;;  init.el --- emacs startup file -*- lexical-binding: t; -*-
#+end_src

** Initialize Benchmarking

#+begin_src emacs-lisp
  (add-hook 'emacs-startup-hook
	    (lambda ()
	      (message "Emacs loaded in %s."
		       (emacs-init-time))))
#+end_src

** System Information

Copy environment constants over from Doom Emacs.

#+begin_src emacs-lisp
  (defconst IS-MAC     (eq system-type 'darwin))
  (defconst IS-LINUX   (eq system-type 'gnu/linux))
  (defconst IS-WINDOWS (memq system-type '(cygwin windows-nt ms-dos)))
  (defconst IS-BSD     (or IS-MAC (eq system-type 'berkeley-unix)))
#+end_src

Copied from crafted emacs

#+begin_src emacs-lisp
  (defun init-using-guix-emacs-p ()
    (unless IS-WINDOWS
      (string-prefix-p "/gnu/store"
		       (file-truename (or (executable-find
					   (car command-line-args))
					  (car command-line-args))))))
  (defconst IS-GUIX (init-using-guix-emacs-p))
#+end_src

** Custom Initialization Hooks

#+begin_src emacs-lisp
  (defun init-unquote (exp)
    (while (memq (car-safe exp) '(quote function))
      (setq exp (cadr exp)))
    exp)
  (defmacro add-transient-hook! (hook-or-function &rest forms)
    "Attaches a self-removing function to HOOK-OR-FUNCTION.

  FORMS are evaluated once, when the hook is first invoked, then
  never again.

  HOOK-OR-FUNCTION can be a quoted hook or a sharp-quoted function.

  This is taken from Doom Emacs."
    (declare (indent 1))
    (let ((append (if (eq (car forms) :after) (pop forms)))
	  (fn (intern (format "init--transient-%d-h"
			      (put 'add-transient-hook! 'counter
				   (1+ (or (get 'add-transient-hook! 'counter)
					   0)))))))
      `(let ((sym ,hook-or-function))
	 (defun ,fn (&rest _)
	   ,(format "Transient hook for %S" (init-unquote hook-or-function))
	   ,@forms
	   (let ((sym ,hook-or-function))
	     (cond ((functionp sym) (advice-remove sym #',fn))
		   ((symbolp sym)   (remove-hook sym #',fn))))
	   (unintern ',fn nil))
	 (cond ((functionp sym)
		(advice-add ,hook-or-function ,(if append :after :before) #',fn))
	       ((symbolp sym)
		(put ',fn 'permanent-local-hook t)
		(add-hook sym #',fn ,append))))))
#+end_src

#+begin_src emacs-lisp
  ;; Doom Style Init Hooks
  (require 'nadvice)
  (defun init-run-hook-on (hook-var trigger-hooks)
    "Configure HOOK-VAR to be invoked exactly once after any TRIGGER-HOOKS.

  This is a simplified version of `doom-run-hook-on' from Doom Emacs.

  HOOK-VAR is a quoted hook.
  TRIGGER-HOOKS is a list of quoted hooks."
    (dolist (hook trigger-hooks)
      (let ((fn (intern (format "%s-init-on-%s-h" hook-var hook))))
	(fset
	 fn (lambda (&rest _)
	      (when (and after-init-time
			 (or (daemonp)
			     (and (boundp hook)
				  (symbol-value hook))))
		(run-hooks hook-var)
		(set hook-var nil))))
	(cond ((daemonp)
	       (add-hook 'after-init-hook fn 'append))
	      ((eq hook 'find-file-hook)
	       (advice-add 'after-find-file :before fn '((depth . -101))))
	      ((add-hook hook fn -101)))
	fn)))
#+end_src

#+begin_src emacs-lisp
(defvar init-first-input-hook nil
  "Transient hooks run before the first user input.")
(put 'init-first-input-hook 'permanent-local t)

(defvar init-first-file-hook nil
  "Transient hooks run before the first interactively opened file.")
(put 'init-first-file-hook 'permanent-local t)

(defvar init-first-buffer-hook nil
  "Transient hooks run before the first interactively opened buffer.")
(put 'init-first-buffer-hook 'permanent-local t)
#+end_src

Finally, we can schedule each of these to go off at the proper time.

#+begin_src emacs-lisp
(unless noninteractive
  (init-run-hook-on 'init-first-buffer-hook '(find-file-hook window-buffer-change-functions))
  (init-run-hook-on 'init-first-file-hook '(find-file-hook dired-initial-position-hook))
  (init-run-hook-on 'init-first-input-hook '(pre-command-hook)))
#+end_src

** Lazy Evaluation Macros
#+begin_src emacs-lisp
  (require 'cl-lib)
  (defmacro after! (package &rest body)
    "Evaluate BODY after PACKAGE has loaded.

  This is a port of doom's `after!' function which itself is a is a
  wrapper around `eval-after-load'."
    (declare (indent defun) (debug t))
    (if (symbolp package)
	(list (if (or (not (bound-and-true-p byte-compile-current-file))
		      (require package nil 'noerror))
		  #'progn
		#'with-no-warnings)
	      `(eval-after-load ',package ',(macroexp-progn body)))
      (let ((p (car package)))
	(cond ((memq p '(:or :any))
	       (macroexp-progn
		(cl-loop for next in (cdr package)
			 collect `(after! ,next ,@body))))
	      ((memq p '(:and :all))
	       (dolist (next (reverse (cdr package)) (car body))
		 (setq body `((after! ,next ,@body)))))
	      (`(after! (:and ,@package) ,@body))))))
#+end_src
** XDG Directories

I want to save files in places that make sense with the XDG
specification, but I also want to use locations that make sense on
Windows.

First define locations to pick the right folder based on the
environment:

#+begin_src emacs-lisp
;; Config Directories
(require 'xdg)
(defun init-data-home ()
  "Find the directory for user specific data files."
  (expand-file-name
   "emacs"
   (if IS-WINDOWS
       (getenv "APPDATA")
     (xdg-data-home))))

(defun init-state-home ()
  "Find the directory for user specific data files.

This directory is for files less portable or less important than
the ones in `init-data-home'."
  (expand-file-name
   "emacs"
   (if IS-WINDOWS
       (getenv "LOCALAPPDATA")
     (xdg--dir-home "XDG_STATE_HOME" "~/.local/state"))))

(defun init-cache-home ()
  "Find the directory for user specific cache files."
  (expand-file-name
   "emacs"
   (if IS-WINDOWS
       (getenv "LOCALAPPDATA")
     (xdg-cache-home))))
#+end_src

Next, I define some convenients functions to build paths to these
standard locations.

#+begin_src emacs-lisp
(require 'cl-lib)
(defun init-path (&rest segments)
  "Assemble SEGMENTS into a complete path string."
  (cl-reduce (lambda (acc segment)
               (expand-file-name segment acc))
             segments))

(defun init-data-path (&rest segments)
  "Assemble SEGMENTS into a path relative to `init-data-home'."
  (apply #'init-path (init-data-home) segments))

(defun init-state-path (&rest segments)
  "Assemble SEGMENTS into a path relative to `init-state-home'."
  (apply #'init-path (init-state-home) segments))

(defun init-cache-path (&rest segments)
  "Assemble SEGMENTS into a path relative to `init-cache-home'."
  (apply #'init-path (init-cache-home) segments))
#+end_src

** Package Management

I want to try to use built in packages where-ever reasonable and to
initialize external packages in a lazy way.

I need a function to initialize straight when I need it:
#+begin_src emacs-lisp
  (defun init-bootstrap-straight ()
    (setq straight-base-dir (init-state-path "./")
	  straight-use-package-by-default t)
    (let ((bootstrap-file
	   (init-state-path "straight" "repos" "straight.el" "bootstrap.el")))
      (unless (file-exists-p bootstrap-file)
	(with-current-buffer
	    (url-retrieve-synchronously
	     "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	     'silent 'inhibit-cookies)
	  (goto-char (point-max))
	  (eval-print-last-sexp)))
      (load bootstrap-file nil 'nomessage))

    ;; install use-package
    (straight-use-package 'use-package)

    (setq use-package-always-ensure nil
	  use-package-always-defer t)

    (provide 'init-straight))
#+end_src

#+begin_src emacs-lisp
  (defun init-package-installed-p (package)
    (unless (or IS-GUIX (featurep 'init-straight))
      (init-bootstrap-straight))
    (condition-case nil
	(when (find-library-name (if (symbolp package)
				     (symbol-name package)
				   package))
	  t)
      (error nil)))
#+end_src

#+begin_src emacs-lisp
  (defun init-ensure-package (package)
    (unless IS-GUIX
      (unless (featurep 'init-straight)
	(init-bootstrap-straight))
      (straight-use-package package)))
#+end_src
 
#+begin_src emacs-lisp
  (defconst NATIVECOMP
    (when (fboundp 'native-comp-available-p)
      (native-comp-available-p)))

  (when NATIVECOMP
    (setq native-comp-deferred-compilation nil
	  native-comp-eln-load-path `(,(init-cache-path "eln/"))))
#+end_src

** Logging

   #+begin_src emacs-lisp
     (defmacro init-log (output &rest args)
       "Copy of `doom-log'."
       `(when (or init-file-debug noninteractive)
	  (let ((inhibit-message t))
	    (message
	     (format
	      "* [%s] %s"
	      ,(let ((time `(format "%.06f" (float-time (time-subtract (current-time) before-init-time)))))
		 (cond (noninteractive time)
		       ((bound-and-true-p init--current-module)
			init--current-module)
		       (time)))
	      ,output)
	     ,@args))))

   #+end_src

** Load Modules

#+begin_src emacs-lisp
  (defvar init--current-module nil)

  (defconst MODULES-DIR
    (expand-file-name "modules/" user-emacs-directory))

  (when (file-directory-p MODULES-DIR)
    (let ((modules (directory-files MODULES-DIR t ".el$")))
      (dolist (module modules)
	(let ((init--current-module module))
	  (load-file module)))))
#+end_src

** Finalize
 #+begin_src emacs-lisp
 (provide 'init)
 ;;; init.el ends here
 #+end_src

* Modules

** Defaults
   :PROPERTIES:
   :header-args: :tangle modules/init-defaults.el
   :END:

   #+begin_src emacs-lisp
     ;;; init-defaults.el -- General Configuration -*- lexical-binding t; -*-

     ;; Encoding
     (require 'seq)
     (seq-doseq (fn '(set-default-coding-systems
		      prefer-coding-system
		      set-terminal-coding-system
		      set-keyboard-coding-system
		      set-buffer-file-coding-system
		      set-selection-coding-system))
       (apply fn (list (if IS-WINDOWS
			   'utf-8-dos
			 'utf-8-unix))))
     (set-language-environment "English")

     ;; Recovery
     (setq auto-save-list-file-prefix
	   (file-name-as-directory
	    (init-cache-path "autosave")))

     (setq auto-save-default t
	   auto-save-timeout 20
	   auto-save-interval 200)

     ;; backups
     (setq backup-directory-alist
	   `(("." . ,(init-cache-path "backups"))))

     (setq make-backup-files t
	   vc-make-backup-files nil
	   backup-by-copying t
	   version-control t
	   kept-old-versions 6
	   kept-new-versions 9
	   delete-by-moving-to-trash t)

     ;; Bookmarks
     ;; TODO: Bookmark keybindings w/ autoloads
     (after! bookmark
       (setq bookmark-default-file
	     (init-cache-path "bookmark")))

     ;; Recentf
       (setq recentf-max-menu-items 50
	     recentf-save-file (init-cache-path "recentf"))
     (add-hook 'init-first-file-hook #'recentf-mode)

     ;; Save History
       ;; https://emacs.stackexchange.com/questions/4187/strip-text-properties-in-savehist
       (defun unpropertize-kill-ring ()
	 "Remove properties from `kill-ring'."
	 (setq kill-ring (mapcar 'substring-no-properties kill-ring)))
       (add-hook 'kill-emacs-hook 'unpropertize-kill-ring)

       (setq kill-ring-max 50
	     history-length 50
	     savehist-file (init-cache-path "history"))
       (setq savehist-additional-variables
	     '(kill-ring
	       command-history
	       set-variable-value-history
	       query-replace-history
	       read-expression-history
	       minibuffer-history
	       read-char-history
	       face-name-history
	       bookmark-history
	       file-name-history))
       (put 'minibuffer-history 'history-length 50)
       (put 'file-name-history 'history-length 50)
       (put 'set-variable-value-history 'history-length 25)
       (put 'query-replace-history 'history-length 25)
       (put 'read-expression-history 'history-length 25)
       (put 'read-char-history 'history-length 25)
       (put 'face-name-history 'history-length 25)
       (put 'bookmark-history 'history-length 25)
       (setq history-delete-duplicates t)

     (add-hook 'init-first-input-hook #'savehist-mode)

     ;; Save Place
       (setq save-place-file (init-cache-path "places")
	     save-place-forget-unreadable-files t)
       (add-hook 'init-first-input-hook #'save-place-mode)

     (provide 'init-defaults)
     ;;; init-defaults.el ends here
   #+end_src
   
** UI
   :PROPERTIES:
   :header-args: :tangle modules/init-ui.el
   :END:

   #+begin_src emacs-lisp
     ;;; init-ui.el -- General Configuration -*- lexical-binding t; -*-
     (defun init-font-exists-p (font-name)
       "Returns `t' if FONT-NAME is a valid font family."
       (member font-name (font-family-list)))

     (defun init-find-font ()
       (cond ((init-font-exists-p "Fira Code")
	      (font-spec :family "Fira Code" :size 18))
	     (t nil)))

     (defun init-variable-pitch-font ()
       (cond ((init-font-exists-p "Fira Sans")
	      (font-spec :family "Fira Sans" :size 18))
	     (t nil)))

     (defvar init-font (init-find-font)
       "The default font to use.

       Inspired by the way Doom Emacs handles `doom-font'.")

     (defvar init-variable-pitch-font (init-variable-pitch-font))
     (defvar init-serif-font nil)

     (defun init-load-fonts ()
       "Loads `init-font'."
       (dolist (pair `((default . ,init-font)
		       (fixed-pitch . ,init-font)
		       (fixed-pitch-serif . ,init-serif-font)
		       (variable-pitch . ,init-variable-pitch-font)))
	 (when-let ((face (car pair))
		     (font (cdr pair)))
	   (set-face-attribute face nil
			       :width 'normal :weight 'normal
			       :slant 'normal :font font))))
     (add-hook 'init-first-buffer-hook
	       #'init-load-fonts)

     (setq hscroll-margin 2
	   hscroll-step 1
	   scroll-conservatively 101
	   scroll-margin 0
	   scroll-preserve-screen-position t
	   auto-window-vscroll nil
	   mouse-wheel-scroll-amount '(2 ((shift) . hscroll))
	   mouse-wheel-scroll-amount-horizontal 2)

     (blink-cursor-mode -1)
     (setq x-stretch-cursor nil)

     (setq indicate-buffer-boundaries nil
	   indicate-empty-lines nil)

     (setq frame-resize-pixelwise t)

     (setq window-resize-pixelwise nil)

     ;; Doom says this is faster than calling the corresponding functions. See
     ;; core-ui.el
     (push '(menu-bar-lines . 0)   default-frame-alist)
     (push '(tool-bar-lines . 0)   default-frame-alist)
     (push '(vertical-scroll-bars) default-frame-alist)
t
     (setq window-divider-default-places t
	   window-divider-default-bottom-width 1
	   window-divider-default-right-width 1)

     (add-hook 'init-first-buffer-hook
	       #'window-divider-mode)

     ;; Avoid inconsistent GUIs
     (setq use-dialog-box nil)
     (when (bound-and-true-p tooltip-mode)
       (tooltip-mode -1))
     (when IS-LINUX
       (setq x-gtk-use-system-tooltips nil))

     (setq split-width-threshold 160
	   split-height-threshold nil)

     (setq enable-recursive-minibuffers t)
     (setq echo-keystrokes 0.02)
     (setq resize-mini-windows 'grow-only)
     (advice-add #'yes-or-no-p :override #'y-or-n-p)

     (setq minibuffer-prompt-properties '(read-only t intangible t cursor-intangible t face minibuffer-prompt))
     (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

     (setq display-line-numbers-type 'relative)
     (add-hook 'prog-mode-hook #'display-line-numbers-mode)

     (provide 'init-ui)
     ;;; init-ui.el ends here
   #+end_src

** Org
   :PROPERTIES:
   :header-args: :tangle modules/init-org.el
   :END:

   #+begin_src emacs-lisp
     ;;; init-org.el -- General Configuration -*- lexical-binding t; -*-

     (provide 'init-org)
     ;;; init-org.el ends here
   #+end_src

** Completion
:PROPERTIES:
:header-args: :tangle modules/init-completion.el :mkdirp t
:END:

#+begin_src emacs-lisp
  ;;; init-completion.el -- completion -*- lexical-binding t; -*-

  (add-hook 'init-first-input-hook #'fido-mode)
  (with-eval-after-load 'icomplete
    (when (fboundp 'fido-vertical-mode)
      (add-hook 'fido-mode-hook #'fido-vertical-mode))
    (customize-set-value 'read-file-name-completion-ignore-case t)
    (customize-set-value 'read-buffer-completion-ignore-case t)
    (customize-set-value 'completion-ignore-case t))

  (provide 'init-completion)
  ;;; init-completion.el ends here
#+end_src

** Projects and Version Control
   :PROPERTIES:
   :header-args: :tangle modules/init-project.el
   :END:

   #+begin_src emacs-lisp
     ;;; init-project.el -- General Configuration -*- lexical-binding t; -*-

     (provide 'init-project)
     ;;; init-project.el ends here
   #+end_src

** LSP
   :PROPERTIES:
   :header-args: :tangle modules/init-lisp.el :mkdirp yes
   :END:

   #+begin_src emacs-lisp
     ;;; init-lsp.el -- General Configuration -*- lexical-binding t; -*-

     (provide 'init-lsp)
     ;;; init-lsp.el ends here
   #+end_src

** Lisp
:PROPERTIES:
:header-args: :tangle modules/init-lisp.el :mkdirp yes
:END:

   #+begin_src emacs-lisp
     ;;; init-lisp.el -- General Configuration -*- lexical-binding t; -*-

     (defvar init-lisp-hooks
       `(emacs-lisp-mode-hook
	 eval-expression-minibuffer-setup-hook
	 ielm-mode-hook
	 lisp-mode-hook
	 scheme-mode-hook
	 ,@(when (init-package-installed-p 'clojure-mode)
	     '(clojure-mode-hook
	       clojurec-mode-hook
	       clojurescrope-mode-hook))))

     (defvar init-first-lisp-mode-hook nil)

     (unless noninteractive
       (init-run-hook-on 'init-first-lisp-mode-hook init-lisp-hooks))

     (defun init-lisp-initialize-module (&rest _)
       (dolist (hook init-lisp-hooks)
	 (init-log "Setting up %s" hook)
	 (init-log "Has paredit? %s"
		   (init-package-installed-p 'paredit))

	 (when (init-package-installed-p 'paredit)
	   (add-hook hook #'enable-paredit-mode))
	 (add-hook hook #'show-paren-mode)))

     (add-hook 'init-first-lisp-mode-hook #'init-lisp-initialize-module)

     (after! geiser-guile
       (add-to-list 'geiser-guile-load-path "~/.config/guix"))

     (provide 'init-lisp)
     ;;; init-lisp.el ends here
   #+end_src
   
