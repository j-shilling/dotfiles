#+AUTHOR: Jake Shilling
#+LANG: en
#+STARTUP: overview
#+PROPERTY: header-args :cache yes :mkdirp yes :padline yes :tangle init.el

* File Header
#+begin_src emacs-lisp
;;;  init.el --- emacs startup file -*- lexical-binding: t; -*-
#+end_src

* Initialize Benchmarking
#+begin_src emacs-lisp
(defvar init-start-time (current-time))
#+end_src

* Environment constants

Copy environment constants over from Doom Emacs.

#+begin_src emacs-lisp
(defconst IS-MAC     (eq system-type 'darwin))
(defconst IS-LINUX   (eq system-type 'gnu/linux))
(defconst IS-WINDOWS (memq system-type '(cygwin windows-nt ms-dos)))
(defconst IS-BSD     (or IS-MAC (eq system-type 'berkeley-unix)))

(defconst LINUX-DISTRIBUTION
  (when IS-LINUX
    (or (when (file-exists-p "/etc/os-release")
          (with-temp-buffer
            (insert-file-contents "/etc/os-release")
            (goto-char (point-min) )
            (when-let ((pos (search-forward "NAME" nil t)))
              (goto-char pos)
              (string-trim
               (cadr
                (split-string
                 (string-trim (thing-at-point 'line))
                 "="))
               "\""
               "\""))))
        (string-trim (shell-command-to-string "uname -o")))))

(defconst IS-GUIX
  (string= LINUX-DISTRIBUTION "Guix System"))
#+end_src

* Custom Initialization Hooks

#+begin_src emacs-lisp
  ;; Doom Style Init Hooks
  (require 'nadvice)
  (defun init-run-hook-on (hook-var trigger-hooks)
    "Configure HOOK-VAR to be invoked exactly once after any TRIGGER-HOOKS.

  This is a simplified version of `doom-run-hook-on' from Doom Emacs.

  HOOK-VAR is a quoted hook.
  TRIGGER-HOOKS is a list of quoted hooks."
    (dolist (hook trigger-hooks)
      (let ((fn (intern (format "%s-init-on-%s-h" hook-var hook))))
	(fset
	 fn (lambda (&rest _)
	      (when (and after-init-time
			 (or (daemonp)
			     (and (boundp hook)
				  (symbol-value hook))))
		(run-hooks hook-var)
		(set hook-var nil))))
	(cond ((daemonp)
	       (add-hook 'after-init-hook fn 'append))
	      ((eq hook 'find-file-hook)
	       (advice-add 'after-find-file :before fn '((depth . -101))))
	      ((add-hook hook fn -101)))
	fn)))
#+end_src

#+begin_src emacs-lisp
(defvar init-first-input-hook nil
  "Transient hooks run before the first user input.")
(put 'init-first-input-hook 'permanent-local t)

(defvar init-first-file-hook nil
  "Transient hooks run before the first interactively opened file.")
(put 'init-first-file-hook 'permanent-local t)

(defvar init-first-buffer-hook nil
  "Transient hooks run before the first interactively opened buffer.")
(put 'init-first-buffer-hook 'permanent-local t)
#+end_src

<<<<<<< HEAD
=======
Finally, we can schedule each of these to go off at the proper time.

#+begin_src emacs-lisp
(unless noninteractive
  (init-run-hook-on 'init-first-buffer-hook '(find-file-hook window-buffer-change-functions))
  (init-run-hook-on 'init-first-file-hook '(find-file-hook dired-initial-position-hook))
  (init-run-hook-on 'init-first-input-hook '(pre-command-hook)))
#+end_src

* Lazy Evaluation Macros
#+begin_src emacs-lisp
  (require 'cl-lib)
  (defmacro after! (package &rest body)
    "Evaluate BODY after PACKAGE has loaded.

  This is a port of doom's `after!' function which itself is a is a
  wrapper around `eval-after-load'."
    (declare (indent defun) (debug t))
    (if (symbolp package)
	(list (if (or (not (bound-and-true-p byte-compile-current-file))
		      (require package nil 'noerror))
		  #'progn
		#'with-no-warnings)
	      `(eval-after-load ',package ',(macroexp-progn body)))
      (let ((p (car package)))
	(cond ((memq p '(:or :any))
	       (macroexp-progn
		(cl-loop for next in (cdr package)
			 collect `(after! ,next ,@body))))
	      ((memq p '(:and :all))
	       (dolist (next (reverse (cdr package)) (car body))
		 (setq body `((after! ,next ,@body)))))
	      (`(after! (:and ,@package) ,@body))))))
#+end_src
* XDG Directories

I want to save files in places that make sense with the XDG
specification, but I also want to use locations that make sense on
Windows.

First define locations to pick the right folder based on the
environment:

#+begin_src emacs-lisp
;; Config Directories
(require 'xdg)
(defun init-data-home ()
  "Find the directory for user specific data files."
  (expand-file-name
   "emacs"
   (if IS-WINDOWS
       (getenv "APPDATA")
     (xdg-data-home))))

(defun init-state-home ()
  "Find the directory for user specific data files.

This directory is for files less portable or less important than
the ones in `init-data-home'."
  (expand-file-name
   "emacs"
   (if IS-WINDOWS
       (getenv "LOCALAPPDATA")
     (xdg--dir-home "XDG_STATE_HOME" "~/.local/state"))))

(defun init-cache-home ()
  "Find the directory for user specific cache files."
  (expand-file-name
   "emacs"
   (if IS-WINDOWS
       (getenv "LOCALAPPDATA")
     (xdg-cache-home))))
#+end_src

Next, I define some convenients functions to build paths to these
standard locations.

#+begin_src emacs-lisp
(require 'cl-lib)
(defun init-path (&rest segments)
  "Assemble SEGMENTS into a complete path string."
  (cl-reduce (lambda (acc segment)
               (expand-file-name segment acc))
             segments))

(defun init-data-path (&rest segments)
  "Assemble SEGMENTS into a path relative to `init-data-home'."
  (apply #'init-path (init-data-home) segments))

(defun init-state-path (&rest segments)
  "Assemble SEGMENTS into a path relative to `init-state-home'."
  (apply #'init-path (init-state-home) segments))

(defun init-cache-path (&rest segments)
  "Assemble SEGMENTS into a path relative to `init-cache-home'."
  (apply #'init-path (init-cache-home) segments))
#+end_src

* Package Management

I want to try to use built in packages where-ever reasonable and to
initialize external packages in a lazy way.

I need a function to initialize straight when I need it:
#+begin_src emacs-lisp
  (unless IS-GUIX
    (setq straight-base-dir (init-state-path)
	  straight-use-package-by-default t)
    (let ((bootstrap-file
	   (init-state-path "straight" "repos" "straight.el" "bootstrap.el")))
      (unless (file-exists-p bootstrap-file)
	(with-current-buffer
	    (url-retrieve-synchronously
	     "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	     'silent 'inhibit-cookies)
	  (goto-char (point-max))
	  (eval-print-last-sexp)))
      (load bootstrap-file nil 'nomessage))

    ;; install use-package
    (straight-use-package 'use-package)
    
    (setq use-package-always-ensure t
	  use-package-always-defer t))
#+end_src

#+begin_src emacs-lisp
  (defconst NATIVECOMP
    (when (fboundp 'native-comp-available-p)
      (native-comp-available-p)))

  (when NATIVECOMP
    (setq native-comp-deferred-compilation nil
	  native-comp-eln-load-path `(,(init-cache-path "eln/"))))
#+end_src
* Core Emacs Configuration
** Startup UI

#+begin_src emacs-lisp
(setq-default
 inhibit-startup-screen t
 inhibit-startup-message t
 inhibit-startup-echo-area-message t
 initial-scratch-message ""
 initial-buffer-choice t)
#+end_src

** Encoding

#+begin_src emacs-lisp
(require 'seq)
(seq-doseq (fn '(set-default-coding-systems
                 prefer-coding-system
                 set-terminal-coding-system
                 set-keyboard-coding-system
                 set-buffer-file-coding-system
                 set-selection-coding-system))
  (apply fn (list (if IS-WINDOWS
                      'utf-8-dos
                    'utf-8-unix))))
(set-language-environment "English")
#+end_src

** Recovery

#+begin_src emacs-lisp
(setq auto-save-list-file-prefix
      (file-name-as-directory
       (init-cache-path "autosave")))

(setq auto-save-default t
      auto-save-timeout 20
      auto-save-interval 200)
#+end_src

** Backups

#+begin_src emacs-lisp
(setq backup-directory-alist
      `(("." . ,(init-cache-path "backups"))))

(setq make-backup-files t
      vc-make-backup-files nil
      backup-by-copying t
      version-control t
      kept-old-versions 6
      kept-new-versions 9
      delete-by-moving-to-trash t)
#+end_src

** Bookmarks

#+begin_src emacs-lisp
  (after! bookmark
    (eval-after-load 'bookmark
      (setq bookmark-default-file
	    (init-cache-path "bookmark"))))
#+end_src

** Recent Files

#+begin_src emacs-lisp
  (setq recentf-max-menu-items 50
	recentf-save-file (init-cache-path "recentf"))
  (add-hook 'init-first-file-hook #'recentf-mode)
#+end_src

** Save History
#+begin_src emacs-lisp
  ;; https://emacs.stackexchange.com/questions/4187/strip-text-properties-in-savehist
  (defun unpropertize-kill-ring ()
    "Remove properties from `kill-ring'."
    (setq kill-ring (mapcar 'substring-no-properties kill-ring)))
  (add-hook 'kill-emacs-hook 'unpropertize-kill-ring)

  (setq kill-ring-max 50
	history-length 50
	savehist-file (init-cache-path "history"))
  (setq savehist-additional-variables
	'(kill-ring
	  command-history
	  set-variable-value-history
	  query-replace-history
	  read-expression-history
	  minibuffer-history
	  read-char-history
	  face-name-history
	  bookmark-history
	  file-name-history))
  (put 'minibuffer-history 'history-length 50)
  (put 'file-name-history 'history-length 50)
  (put 'set-variable-value-history 'history-length 25)
  (put 'query-replace-history 'history-length 25)
  (put 'read-expression-history 'history-length 25)
  (put 'read-char-history 'history-length 25)
  (put 'face-name-history 'history-length 25)
  (put 'bookmark-history 'history-length 25)
  (setq history-delete-duplicates t)

  (add-hook 'init-first-input-hook #'savehist-mode)
#+end_src

** Save Place in File
#+begin_src emacs-lisp
  (setq save-place-file (init-cache-path "places")
	save-place-forget-unreadable-files t)
  (add-hook 'init-first-input-hook #'save-place-mode)
#+end_src

** Start Server
#+begin_src emacs-lisp
(require 'server)
(unless (server-running-p)
  (server-start))
#+end_src

* Emacs UI

#+begin_src emacs-lisp
  (defun init-font-exists-p (font-name)
    "Returns `t' if FONT-NAME is a valid font family."
    (member font-name (font-family-list)))

  (defun init-find-font ()
    (cond ((init-font-exists-p "Fira Code")
	   (font-spec :family "Fira Code" :size 18))
	  (t nil)))

  (defun init-variable-pitch-font ()
    (cond ((init-font-exists-p "Fira Sans")
	   (font-spec :family "Fira Sans" :size 18))
	  (t nil)))

  (defvar init-font (init-find-font)
    "The default font to use.

  Inspired by the way Doom Emacs handles `doom-font'.")

  (defvar init-variable-pitch-font (init-variable-pitch-font))
  (defvar init-serif-font nil)

  (defun init-load-fonts ()
    "Loads `init-font'."
    (dolist (pair `((default . ,init-font)
		    (fixed-pitch . ,init-font)
		    (fixed-pitch-serif . ,init-serif-font)
		    (variable-pitch . ,init-variable-pitch-font)))
      (when-let* ((face (car pair))
		  (font (cdr pair)))
	  (set-face-attribute face nil
			    :width 'normal :weight 'normal
			    :slant 'normal :font font))))
  (add-hook 'init-first-buffer-hook
	    #'init-load-fonts)

  (setq hscroll-margin 2
	hscroll-step 1
	scroll-conservatively 101
	scroll-margin 0
	scroll-preserve-screen-position t
	auto-window-vscroll nil
	mouse-wheel-scroll-amount '(2 ((shift) . hscroll))
	mouse-wheel-scroll-amount-horizontal 2)

  (blink-cursor-mode -1)
  (setq x-stretch-cursor nil)

  (setq indicate-buffer-boundaries nil
	indicate-empty-lines nil)

  (setq frame-resize-pixelwise t)

  (setq window-resize-pixelwise nil)

  ;; Doom says this is faster than calling the corresponding functions. See
  ;; core-ui.el
  (push '(menu-bar-lines . 0)   default-frame-alist)
  (push '(tool-bar-lines . 0)   default-frame-alist)
  (push '(vertical-scroll-bars) default-frame-alist)

  (setq window-divider-default-places t
	window-divider-default-bottom-width 1
	window-divider-default-right-width 1)

  (add-hook 'init-first-buffer-hook
	    #'window-divider-mode)

  ;; Avoid inconsistent GUIs
  (setq use-dialog-box nil)
  (when (bound-and-true-p tooltip-mode)
    (tooltip-mode -1))
  (when IS-LINUX
    (setq x-gtk-use-system-tooltips nil))

  (setq split-width-threshold 160
	split-height-threshold nil)

  (setq enable-recursive-minibuffers t)
  (setq echo-keystrokes 0.02)
  (setq resize-mini-windows 'grow-only)
  (advice-add #'yes-or-no-p :override #'y-or-n-p)

  (setq minibuffer-prompt-properties '(read-only t intangible t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
#+end_src

* General Programming

** Git

#+begin_src emacs-lisp
  (use-package magit
    :bind ("C-x g" . #'magit-status))
#+end_src

* Lisp

#+begin_src emacs-lisp
  (use-package paredit
    :init
    (autoload 'enable-paredit-mode
      "paredit" "Turn on paredit." t)
    :hook
    ((emacs-lisp-mode . enable-paredit-mode)
     (eval-expression-minibuffer-setup . enable-paredit-mode)
     (ielm-mode . enable-paredit-mode)
     (lisp-mode . enable-paredit-mode)
     (scheme-mode . enable-paredit-mode)))
#+end_src

** Clojure

#+begin_src emacs-lisp
  (use-package clojure-mode)
  (use-package cider
    :hook ((cider-mode . eldoc-mode)))
  (use-package clj-refactor)
  (use-package flycheck-clj-kondo)
#+end_src

* Show Benchmarking

#+begin_src emacs-lisp
(let ((init-time (float-time (time-subtract (current-time) init-start-time)))
      (total-time (string-to-number (emacs-init-time "%f"))))
  (message "Initialization time %.2fs (+ %.2f system time)"
           init-time (- total-time init-time)))
#+end_src

* Finalize
#+begin_src emacs-lisp
(provide 'init)
;;; init.el ends here
#+end_src
