#+AUTHOR: Jake Shilling
#+LANG: en
#+STARTUP: overview
#+PROPERTY: header-args :cache yes :mkdirp yes :padline yes :tangle init.el

* Early Init
:PROPERTIES:
:header-args: :tangle early-init.el
:END:

#+begin_src emacs-lisp
  ;;; early-init.el -*- lexical-binding: t; -*-

  (setq gc-cons-threshold most-positive-fixnum)
  (add-hook 'after-init-hook
            (lambda ()
              (setq gc-cons-threshold (* 1025 10))))

  (setq package-enable-at-startup nil)

  (setq load-prefer-newer noninteractive)

  ;; Doom says this is faster than calling the corresponding functions. See
  ;; core-ui.el
  (push '(menu-bar-lines . 0)   default-frame-alist)
  (push '(tool-bar-lines . 0)   default-frame-alist)
  (push '(vertical-scroll-bars) default-frame-alist)

  (when (featurep 'native-compile)
    (setq native-comp-async-report-warnings-errors nil
          native-comp-deferred-compilation t))

  ;;; early-init.el ends here
#+end_src

* Init
:PROPERTIES:
:header-args: :tangle init.el
:END:

** File Header
#+begin_src emacs-lisp
;;;  init.el --- emacs startup file -*- lexical-binding: t; -*-
#+end_src

** Initialize Benchmarking

#+begin_src emacs-lisp
  (add-hook 'emacs-startup-hook
            (lambda ()
              (message "Emacs loaded in %s."
                       (emacs-init-time))))
#+end_src

** System Information

Copy environment constants over from Doom Emacs.

#+begin_src emacs-lisp
  (defconst IS-MAC     (eq system-type 'darwin))
  (defconst IS-LINUX   (eq system-type 'gnu/linux))
  (defconst IS-WINDOWS (memq system-type '(cygwin windows-nt ms-dos)))
  (defconst IS-BSD     (or IS-MAC (eq system-type 'berkeley-unix)))
#+end_src

Copied from crafted emacs

#+begin_src emacs-lisp
  (defun init-using-guix-emacs-p ()
    (unless IS-WINDOWS
      (string-prefix-p "/gnu/store"
                       (file-truename (or (executable-find
                                           (car command-line-args))
                                          (car command-line-args))))))
  (defconst IS-GUIX (init-using-guix-emacs-p))
#+end_src

** Custom Initialization Hooks

#+begin_src emacs-lisp
  (defun init-unquote (exp)
    (while (memq (car-safe exp) '(quote function))
      (setq exp (cadr exp)))
    exp)
  (defmacro add-transient-hook! (hook-or-function &rest forms)
    "Attaches a self-removing function to HOOK-OR-FUNCTION.

  FORMS are evaluated once, when the hook is first invoked, then
  never again.

  HOOK-OR-FUNCTION can be a quoted hook or a sharp-quoted function.

  This is taken from Doom Emacs."
    (declare (indent 1))
    (let ((append (if (eq (car forms) :after) (pop forms)))
          (fn (intern (format "init--transient-%d-h"
                              (put 'add-transient-hook! 'counter
                                   (1+ (or (get 'add-transient-hook! 'counter)
                                           0)))))))
      `(let ((sym ,hook-or-function))
         (defun ,fn (&rest _)
           ,(format "Transient hook for %S" (init-unquote hook-or-function))
           ,@forms
           (let ((sym ,hook-or-function))
             (cond ((functionp sym) (advice-remove sym #',fn))
                   ((symbolp sym)   (remove-hook sym #',fn))))
           (unintern ',fn nil))
         (cond ((functionp sym)
                (advice-add ,hook-or-function ,(if append :after :before) #',fn))
               ((symbolp sym)
                (put ',fn 'permanent-local-hook t)
                (add-hook sym #',fn ,append))))))
#+end_src

#+begin_src emacs-lisp
  ;; Doom Style Init Hooks
  (require 'nadvice)
  (defun init-run-hook-on (hook-var trigger-hooks)
    "Configure HOOK-VAR to be invoked exactly once after any TRIGGER-HOOKS.

  This is a simplified version of `doom-run-hook-on' from Doom Emacs.

  HOOK-VAR is a quoted hook.
  TRIGGER-HOOKS is a list of quoted hooks."
    (dolist (hook trigger-hooks)
      (let ((fn (intern (format "%s-init-on-%s-h" hook-var hook))))
        (fset
         fn (lambda (&rest _)
              (when (and after-init-time
                         (or (daemonp)
                             (and (boundp hook)
                                  (symbol-value hook))))
                (run-hooks hook-var)
                (set hook-var nil))))
        (cond ((daemonp)
               (add-hook 'after-init-hook fn 'append))
              ((eq hook 'find-file-hook)
               (advice-add 'after-find-file :before fn '((depth . -101))))
              ((add-hook hook fn -101)))
        fn)))
#+end_src

#+begin_src emacs-lisp
(defvar init-first-input-hook nil
  "Transient hooks run before the first user input.")
(put 'init-first-input-hook 'permanent-local t)

(defvar init-first-file-hook nil
  "Transient hooks run before the first interactively opened file.")
(put 'init-first-file-hook 'permanent-local t)

(defvar init-first-buffer-hook nil
  "Transient hooks run before the first interactively opened buffer.")
(put 'init-first-buffer-hook 'permanent-local t)
#+end_src

Finally, we can schedule each of these to go off at the proper time.

#+begin_src emacs-lisp
(unless noninteractive
  (init-run-hook-on 'init-first-buffer-hook '(find-file-hook window-buffer-change-functions))
  (init-run-hook-on 'init-first-file-hook '(find-file-hook dired-initial-position-hook))
  (init-run-hook-on 'init-first-input-hook '(pre-command-hook)))
#+end_src

** Lazy Evaluation Macros
#+begin_src emacs-lisp
  (require 'cl-lib)
  (defmacro after! (package &rest body)
    "Evaluate BODY after PACKAGE has loaded.

  This is a port of doom's `after!' function which itself is a is a
  wrapper around `eval-after-load'."
    (declare (indent defun) (debug t))
    (if (symbolp package)
        (list (if (or (not (bound-and-true-p byte-compile-current-file))
                      (require package nil 'noerror))
                  #'progn
                #'with-no-warnings)
              `(eval-after-load ',package ',(macroexp-progn body)))
      (let ((p (car package)))
        (cond ((memq p '(:or :any))
               (macroexp-progn
                (cl-loop for next in (cdr package)
                         collect `(after! ,next ,@body))))
              ((memq p '(:and :all))
               (dolist (next (reverse (cdr package)) (car body))
                 (setq body `((after! ,next ,@body)))))
              (`(after! (:and ,@package) ,@body))))))
#+end_src
** XDG Directories

I want to save files in places that make sense with the XDG
specification, but I also want to use locations that make sense on
Windows.

First define locations to pick the right folder based on the
environment:

#+begin_src emacs-lisp
;; Config Directories
(require 'xdg)
(defun init-data-home ()
  "Find the directory for user specific data files."
  (expand-file-name
   "emacs"
   (if IS-WINDOWS
       (getenv "APPDATA")
     (xdg-data-home))))

(defun init-state-home ()
  "Find the directory for user specific data files.

This directory is for files less portable or less important than
the ones in `init-data-home'."
  (expand-file-name
   "emacs"
   (if IS-WINDOWS
       (getenv "LOCALAPPDATA")
     (xdg--dir-home "XDG_STATE_HOME" "~/.local/state"))))

(defun init-cache-home ()
  "Find the directory for user specific cache files."
  (expand-file-name
   "emacs"
   (if IS-WINDOWS
       (getenv "LOCALAPPDATA")
     (xdg-cache-home))))
#+end_src

Next, I define some convenients functions to build paths to these
standard locations.

#+begin_src emacs-lisp
(require 'cl-lib)
(defun init-path (&rest segments)
  "Assemble SEGMENTS into a complete path string."
  (cl-reduce (lambda (acc segment)
               (expand-file-name segment acc))
             segments))

(defun init-data-path (&rest segments)
  "Assemble SEGMENTS into a path relative to `init-data-home'."
  (apply #'init-path (init-data-home) segments))

(defun init-state-path (&rest segments)
  "Assemble SEGMENTS into a path relative to `init-state-home'."
  (apply #'init-path (init-state-home) segments))

(defun init-cache-path (&rest segments)
  "Assemble SEGMENTS into a path relative to `init-cache-home'."
  (apply #'init-path (init-cache-home) segments))
#+end_src

** Package Management

I want to try to use built in packages where-ever reasonable and to
initialize external packages in a lazy way.

I need a function to initialize straight when I need it:
#+begin_src emacs-lisp
  (defun init-bootstrap-straight ()
    (setq straight-base-dir (init-state-path "./")
          straight-use-package-by-default t)
    (let ((bootstrap-file
           (init-state-path "straight" "repos" "straight.el" "bootstrap.el")))
      (unless (file-exists-p bootstrap-file)
        (with-current-buffer
            (url-retrieve-synchronously
             "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
             'silent 'inhibit-cookies)
          (goto-char (point-max))
          (eval-print-last-sexp)))
      (load bootstrap-file nil 'nomessage))

    ;; install use-package
    (straight-use-package 'use-package)

    (setq use-package-always-ensure nil
          use-package-always-defer t)

    (provide 'init-straight))
#+end_src

#+begin_src emacs-lisp
  (defun init-package-installed-p (package)
    (if IS-GUIX
        (progn
          (let ((autoload-name (format "%s-autoloads" package)))
            (featurep (intern autoload-name))))
      (progn
        (unless (featurep 'init-straight)
          (error "Not implemented")))))

  (unless (featurep 'testing)
    (dolist (hook '(init-first-file-hook
                    init-first-buffer-hook
                    init-first-input-hook
                    after-init-hook
                    emacs-startup-hook
                    window-setup-hook))
      (add-hook hook
                (lambda ()
                  (init-log "%s: (init-package-installed-p 'paredit) %s"
                            hook
                            (init-package-installed-p 'paredit)))))
    (provide 'testing))
#+end_src

#+begin_src emacs-lisp
  (defun init-ensure-package (package)
    (unless IS-GUIX
      (unless (featurep 'init-straight)
        (init-bootstrap-straight))
      (straight-use-package package)))
#+end_src
 
#+begin_src emacs-lisp
  (defconst NATIVECOMP
    (when (fboundp 'native-comp-available-p)
      (native-comp-available-p)))

  (when NATIVECOMP
    (setq native-comp-deferred-compilation nil
          native-comp-eln-load-path `(,(init-cache-path "eln/"))))
#+end_src

** Logging

   #+begin_src emacs-lisp
     (defmacro init-log (output &rest args)
       "Copy of `doom-log'."
       `(when (or init-file-debug noninteractive)
          (let ((inhibit-message t))
            (message
             (format
              "* [%s] %s"
              ,(let ((time `(format "%.06f" (float-time (time-subtract (current-time) before-init-time)))))
                 (cond (noninteractive time)
                       ((bound-and-true-p init--current-module)
                        init--current-module)
                       (time)))
              ,output)
             ,@args))))

   #+end_src

** Load Modules

#+begin_src emacs-lisp
  (defvar init--current-module nil)

  (defconst MODULES-DIR
    (expand-file-name "modules/" user-emacs-directory))

  (when (file-directory-p MODULES-DIR)
    (let ((modules (directory-files MODULES-DIR t ".el$")))
      (dolist (module modules)
        (let ((init--current-module module))
          (load-file module)))))
#+end_src

** Finalize
 #+begin_src emacs-lisp
 (provide 'init)
 ;;; init.el ends here
 #+end_src

* Modules

** Defaults
   :PROPERTIES:
   :header-args: :tangle modules/init-defaults.el :mkdirp t
   :END:
*** Header
#+begin_src emacs-lisp
     ;;; init-defaults.el -- General Configuration -*- lexical-binding: t; -*-
#+end_src
*** Encoding
#+begin_src emacs-lisp
     ;; Encoding
     (require 'seq)
     (seq-doseq (fn '(set-default-coding-systems
                      prefer-coding-system
                      set-terminal-coding-system
                      set-keyboard-coding-system
                      set-buffer-file-coding-system
                      set-selection-coding-system))
       (apply fn (list (if IS-WINDOWS
                           'utf-8-dos
                         'utf-8-unix))))
     (set-language-environment "English")
#+end_src
*** Tabs
#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq-default tab-width 4)
#+end_src
*** Editing
#+begin_src emacs-lisp
  (add-hook 'init-first-input-hook #'delete-selection-mode)
  (add-hook 'init-first-file-hook #'global-auto-revert-mode)
  (after! whitespace
    (customize-set-value 'whitespace-action '(cleanup auto-cleanup)))
#+end_src
*** File recovery
#+begin_src emacs-lisp
  ;; Recovery
  (setq auto-save-list-file-prefix
        (file-name-as-directory
         (init-cache-path "autosave")))

  (setq auto-save-default t
        auto-save-timeout 20
        auto-save-interval 200)
  ;; backups
  (setq backup-directory-alist
        `(("." . ,(init-cache-path "backups"))))

  (setq make-backup-files t
        vc-make-backup-files nil
        backup-by-copying t
        version-control t
        kept-old-versions 6
        kept-new-versions 9
        delete-by-moving-to-trash t)

#+end_src
*** Bookmarks + Recent Files
#+begin_src emacs-lisp
     ;; Bookmarks
     ;; TODO: Bookmark keybindings w/ autoloads
     (after! bookmark
       (setq bookmark-default-file
             (init-cache-path "bookmark")))

     ;; Recentf
       (setq recentf-max-menu-items 50
             recentf-save-file (init-cache-path "recentf"))
     (add-hook 'init-first-file-hook #'recentf-mode)
#+end_src
*** History
#+begin_src emacs-lisp
  ;; Save History
  ;; https://emacs.stackexchange.com/questions/4187/strip-text-properties-in-savehist
  (defun unpropertize-kill-ring ()
    "Remove properties from `kill-ring'."
    (setq kill-ring (mapcar 'substring-no-properties kill-ring)))
  (add-hook 'kill-emacs-hook 'unpropertize-kill-ring)

  (setq kill-ring-max 50
        history-length 50
        savehist-file (init-cache-path "history"))
  (setq savehist-additional-variables
        '(kill-ring
          command-history
          set-variable-value-history
          query-replace-history
          read-expression-history
          minibuffer-history
          read-char-history
          face-name-history
          bookmark-history
          file-name-history))
  (put 'minibuffer-history 'history-length 50)
  (put 'file-name-history 'history-length 50)
  (put 'set-variable-value-history 'history-length 25)
  (put 'query-replace-history 'history-length 25)
  (put 'read-expression-history 'history-length 25)
  (put 'read-char-history 'history-length 25)
  (put 'face-name-history 'history-length 25)
  (put 'bookmark-history 'history-length 25)
  (setq history-delete-duplicates t)

  (add-hook 'init-first-input-hook #'savehist-mode)

  ;; Save Place
  (setq save-place-file (init-cache-path "places")
        save-place-forget-unreadable-files t)
  (add-hook 'init-first-input-hook #'save-place-mode)

  ;; kill ring
  (setq kill-do-not-save-duplicates t)
#+end_src
*** Prompts
#+begin_src emacs-lisp
  (setq minibuffer-prompt-properties '(read-only t intangible t cursor-intangible t face minibuffer-prompt))

  (if (boundp 'use-short-answers)
      (setq use-short-answers t)
    (advice-add 'yes-or-no-p :override #'y-or-n-p))
#+end_src
*** Files With Long Lines
#+begin_src emacs-lisp
  (setq bidi-paragraph-direction 'left-to-right
        bidi-inhibit-bpa t)

  (add-hook 'init-first-buffer-hook
            (lambda ()
              (global-so-long-mode 1)))
#+end_src
*** Footer
#+begin_src emacs-lisp
  (provide 'init-defaults)
  ;;; init-defaults.el ends here
#+end_src
   
** UI
   :PROPERTIES:
   :header-args: :tangle modules/init-ui.el
   :END:

*** Header
#+begin_src emacs-lisp
;;; init-ui.el -- General Configuration -*- lexical-binding: t; -*-
#+end_src

*** Frame defaults
#+begin_src emacs-lisp
     ;; frame defaults
     (setq default-frame-alist
           '((min-heigt . 1)
             (height . 45)
             (min-width . 1)
             (width . 81)
             (vertical-scroll-bars . nil)
             (internal-border-width . 14)
             (left-fringe . 1)
             (right-fringe . 1)
             (tool-bar-lines . 0)
             (menu-bar-lines . 0)))
#+end_src

*** Cleanup UI

#+begin_src emacs-lisp
  ;; Turn of decorations
  (setq inhibit-startup-screen t
        inhibit-startup-message t
        inhibit-startup-echo-area-message t
        initial-scratch-message nil)

  (setq indicate-buffer-boundaries nil
        indicate-empty-lines nil)

  ;; Avoid inconsistent GUIs
  (setq use-dialog-box nil)
  (when (bound-and-true-p tooltip-mode)
    (tooltip-mode -1))
  (when IS-LINUX
    (setq x-gtk-use-system-tooltips nil))
#+end_src

*** Font
#+begin_src emacs-lisp
  ;; Fonts
  (defun init-font-exists-p (font-name)
    "Returns `t' if FONT-NAME is a valid font family."
    (member font-name (font-family-list)))

  (defun init-find-font ()
    (cond ((init-font-exists-p "Fira Code")
           (font-spec :family "Fira Code" :size 18))
          (t nil)))

  (defun init-variable-pitch-font ()
    (cond ((init-font-exists-p "Fira Sans")
           (font-spec :family "Fira Sans" :size 18))
          (t nil)))

  (defvar init-font (init-find-font)
    "The default font to use.

         Inspired by the way Doom Emacs handles `doom-font'.")

  (defvar init-variable-pitch-font (init-variable-pitch-font))
  (defvar init-serif-font nil)

  (defun init-load-fonts ()
    "Loads `init-font'."
    (dolist (pair `((default . ,init-font)
                    (fixed-pitch . ,init-font)
                    (fixed-pitch-serif . ,init-serif-font)
                    (variable-pitch . ,init-variable-pitch-font)))
      (when-let ((face (car pair))
                 (font (cdr pair)))
        (set-face-attribute face nil
                            :width 'normal :weight 'normal
                            :slant 'normal :font font))))

  (add-hook 'init-first-buffer-hook
            #'init-load-fonts)
#+end_src

*** Scrolling
#+begin_src emacs-lisp
  (setq hscroll-margin 2
        hscroll-step 1
        scroll-conservatively 101
        scroll-margin 0
        scroll-preserve-screen-position t
        auto-window-vscroll nil
        mouse-wheel-scroll-amount '(2 ((shift) . hscroll))
        mouse-wheel-scroll-amount-horizontal 2)
#+end_src

*** Window Splitting

#+begin_src emacs-lisp
  (setq window-divider-default-places t
        window-divider-default-bottom-width 1
        window-divider-default-right-width 1)

  (setq split-width-threshold 160
        split-height-threshold nil)

  (add-hook 'init-first-buffer-hook
            #'window-divider-mode)
#+end_src

*** Cursor
#+begin_src emacs-lisp
  (setq x-stretch-cursor nil)

  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
  (add-hook 'init-first-buffer-hook (lambda ()
                                      (blink-cursor-mode -1)))
#+end_src

*** Resizing
#+begin_src emacs-lisp
     (setq frame-resize-pixelwise t)

     (setq window-resize-pixelwise nil)

     ;; Doom says this is faster than calling the corresponding functions. See
     ;; core-ui.el
     (push '(menu-bar-lines . 0)   default-frame-alist)
     (push '(tool-bar-lines . 0)   default-frame-alist)
     (push '(vertical-scroll-bars) default-frame-alist)
     t
     (setq window-divider-default-places t
           window-divider-default-bottom-width 1
           window-divider-default-right-width 1)

     (add-hook 'init-first-buffer-hook
               #'window-divider-mode)

     ;; Avoid inconsistent GUIs
     (setq use-dialog-box nil)
     (when (bound-and-true-p tooltip-mode)
       (tooltip-mode -1))
     (when IS-LINUX
       (setq x-gtk-use-system-tooltips nil))

     (setq split-width-threshold 160
           split-height-threshold nil)

     (setq enable-recursive-minibuffers t)
     (setq echo-keystrokes 0.02)
     (setq resize-mini-windows 'grow-only)
#+end_src

*** Theme

#+begin_src emacs-lisp
  (setq modus-themes-bold-constructs t
        modus-themes-italic-constructs t
        modus-themes-syntax '(yellow-comments)
        modus-themes-mixed-fonts t
        modus-themes-prompts '(intense bold)
        modus-themes-completions '((matches . (intense))
                                   (selection . (intense accented text-also italic)))
        modus-themes-lang-checkers '(intense straight-underline)
        modus-themes-subtle-line-numbers nil
        modus-themes-paren-match '(bold intense)
        modus-themes-region '(accented bg-only)
        modus-themes-variable-pitch-ui t)

  (setq modus-themes-markup nil
        modus-themes-org-blocks 'gray-background
        modus-themes-org-agenda nil
        modus-themes-headings nil)

  (add-hook 'init-first-buffer-hook
            (lambda ()
              (load-theme 'modus-vivendi t)))
#+end_src

*** Footer
#+begin_src emacs-lisp
  (provide 'init-ui)
  ;;; init-ui.el ends here
#+end_src

** Org
   :PROPERTIES:
   :header-args: :tangle modules/init-org.el
   :END:

   #+begin_src emacs-lisp
     ;;; init-org.el -- General Configuration -*- lexical-binding: t; -*-

     (setq org-special-ctrl-a/e t
           org-special-ctrl-k t
           org-startup-indented t
           org-log-done t
           org-src-fontify-natively t
           org-src-tab-acts-natively t
           org-confirm-babel-evaluate nil
           org-hide-emphasis-markers t
           org-pretty-entities t
           org-log-into-drawer t
           org-clock-report-include-clocking-task t
           org-clock-out-when-done t
           org-clock-out-remove-zero-time-clocks t
           org-clock-persist t
           org-clock-in-resume t
           org-clock-persist-query-resume nil
           org-modules '(org-habit))

     (setq org-ellipsis " â†“ "
           org-pretty-entities t
           org-fontify-whole-heading-line t
           org-fontify-done-headline t
           org-fontify-quote-and-verse-blocks t
           org-hide-emphasis-markers t)

     (when (init-package-installed-p 'org-appear)
       (after! org
         (add-hook 'org-mode #'org-appear-mode)))

     (provide 'init-org)
     ;;; init-org.el ends here
   #+end_src

** Completion
:PROPERTIES:
:header-args: :tangle modules/init-completion.el :mkdirp t
:END:

#+begin_src emacs-lisp
  ;;; init-completion.el -- completion -*- lexical-binding: t; -*-

  (add-hook 'init-first-input-hook #'fido-mode)
  (after! 'icomplete
    (when (fboundp 'fido-vertical-mode)
      (add-hook 'fido-mode-hook #'fido-vertical-mode))
    (customize-set-value 'read-file-name-completion-ignore-case t)
    (customize-set-value 'read-buffer-completion-ignore-case t)
    (customize-set-value 'completion-ignore-case t))

  (when (init-package-installed-p 'corfu)
    (add-hook 'init-first-buffer-hook #'global-corfu-mode)
    (after! corfu
      (customize-set-value 'corfu-cycle t)
      (customize-set-value 'corfu-auto t)
      (customize-set-value 'corfu-separator ?\s)
      (customize-set-value 'corfu-quit-at-boundary t)
      (customize-set-value 'corfu-quit-no-match t)
      (customize-set-value 'corfu-preview-current t)
      (customize-set-value 'corfu-preselect-first nil)
      (customize-set-value 'corfu-on-exact-match 'insert)
      (customize-set-value 'corfu-echo-documentation t)
      (customize-set-value 'corfu-scroll-margin 5))

    (setq completion-cycle-threshold 3
          tab-always-indent 'complete)

    (when (init-package-installed-p 'cape)
      (after! corfu
        (setq completion-at-point-functions
              (list #'cape-dabbrev
                    #'cape-abbrev
                    #'cape-ispell))
        (add-hook 'prog-mode-hook
                  (lambda ()
                    (interactive)
                    (add-hook 'completion-at-point-functions
                              #'cape-keyword nil t)))

        (add-hook 'emacs-lisp-mode
                  (lambda ()
                    (interactive)
                    (add-hook 'completion-at-point-functions
                              #'cape-symbol nil t)))

        (add-hook 'latex-mode-hook
                  (lambda ()
                    (interactive)
                    (add-hook 'completion-at-point-functions
                              #'cape-tex nil t))))))

  (when (init-package-installed-p 'yasnippet)
    (add-hook 'init-first-input-hook #'yas-global-mode)
    (define-key yas-minor-mode-map (kbd "SPC") yas-maybe-expand)

    (add-hook 'yas-after-exit-snippet-hook
              (lambda ()
                (when (eq major-mode 'clojure-mode)
                  (when (and (eq ?\( (char-before yas-snippet-beg))
                             (eq ?\) (char-after yas-snippet-end)))
                    (save-excursion
                      (goto-char yas-snippet-beg)
                      (paredit-raise-sexp)))))))

  (provide 'init-completion)
  ;;; init-completion.el ends here
#+end_src

** Gpg and Pinentry
:PROPERTIES:
:header-args: :tangle modules/init-gpg.el :mkdirp t
:END:

#+begin_src emacs-lisp
  ;;; init-gpg.el -- GPG Configuration -*- lexical-binding: t; -*-

  (when (init-package-installed-p 'pinentry)
    (setq epa-pinentry-mode 'loopback
          epa-file-select-keys nil
          epa-file-encrypt-to "0FCC8E6A96FF109F"
          epa-file-cache-passphrase-for-symmetric-encryption t
          epa-file-inhibit-auto-save t)
    (add-hook 'after-init-hook #'pinentry-start))

  (provide 'init-gpg)
  ;;;init-gpg.el ends here
#+end_src

** Projects and Version Control
   :PROPERTIES:
   :header-args: :tangle modules/init-project.el
   :END:

   #+begin_src emacs-lisp
     ;;; init-project.el -- General Configuration -*- lexical-binding: t; -*-
     (when (init-package-installed-p 'magit)
       (global-set-key (kbd "C-x g") #'magit-status))

     (setq project-list-file (init-state-path "projects"))

     (provide 'init-project)
     ;;; init-project.el ends here
   #+end_src

** Programming
   :PROPERTIES:
   :header-args: :tangle modules/init-lsp.el :mkdirp yes
   :END:

   #+begin_src emacs-lisp
     ;;; init-prog.el -- General Programming Configuration -*- lexical-binding: t; -*-

     (add-hook 'prog-mode-hook #'flymake-mode-on)

     (setq display-line-numbers-type 'relative)
     (add-hook 'prog-mode-hook #'display-line-numbers-mode)

     (add-hook 'prog-mode-hook #'whitespace-mode)

     (provide 'init-prog)
     ;;; init-lsp.el ends here
   #+end_src

** Lisp
:PROPERTIES:
:header-args: :tangle modules/init-lisp.el :mkdirp yes
:END:

   #+begin_src emacs-lisp
     ;;; init-lisp.el -- General Configuration -*- lexical-binding: t; -*-

     (defvar init-lisp-hooks
       `(emacs-lisp-mode-hook
         eval-expression-minibuffer-setup-hook
         ielm-mode-hook
         lisp-mode-hook
         scheme-mode-hook
         ,@(when (init-package-installed-p 'geiser)
             '(geiser-repl-mode-hook))
         ,@(when (init-package-installed-p 'clojure-mode)
             '(clojure-mode-hook
               clojurec-mode-hook
               clojurescrope-mode-hook))
         ,@(when (init-package-installed-p 'cider)
             '(cider-repl-mode-hook))))

     (dolist (hook init-lisp-hooks)
       (when (init-package-installed-p 'paredit)
         (add-hook hook #'enable-paredit-mode))
       (add-hook hook #'show-paren-mode))

     (after! geiser-guile
       (setq geiser-guile-load-path
             (when-let ((guile-load-path (getenv "GUILE_LOAD_PATH")))
               (split-string guile-load-path ":"))))

     (provide 'init-lisp)
     ;;; init-lisp.el ends here
   #+end_src
   
   
