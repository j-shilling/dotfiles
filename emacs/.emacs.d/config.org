#+AUTHOR: Jake Shilling
#+LANG: en
#+STARTUP: overview
#+PROPERTY: header-args :cache yes :mkdirp yes :padline yes :comments link :tangle init.el

* File Header
#+begin_src emacs-lisp
;;;  init.el --- emacs startup file -*- lexical-binding: t; -*-
#+end_src

* Initialize Benchmarking
#+begin_src emacs-lisp
(defvar init-start-time (current-time))
#+end_src

* Environment constants

Copy environment constants over from Doom Emacs.

#+begin_src emacs-lisp
(defconst IS-MAC     (eq system-type 'darwin))
(defconst IS-LINUX   (eq system-type 'gnu/linux))
(defconst IS-WINDOWS (memq system-type '(cygwin windows-nt ms-dos)))
(defconst IS-BSD     (or IS-MAC (eq system-type 'berkeley-unix)))
#+end_src

* Custom Initialization Hooks

Take Doom's fancy-dancy startup hooks to make initialization very
lazy. First we need to copy over =doom-run-hook-on=, which schedules
a hook to be run after certain triggers. This is like =add-hook=
except that it takes into account whether Emacs has finished starting
up and whether it's being run as a daemon.

#+begin_src emacs-lisp
;; Doom Style Init Hooks
(require 'nadvice)
(defun init-run-hook-on (hook-var trigger-hooks)
  "Configure HOOK-VAR to be invoked exactly once after any TRIGGER-HOOKS.

This is a simplified version of `doom-run-hook-on' from Doom Emacs.

HOOK-VAR is a quoted hook.
TRIGGER-HOOKS is a list of quoted hooks."
  (dolist (hook trigger-hooks)
    (let ((fn (intern (format "%s-init-on-%s-h" hook-var hook))))
      (fset
       fn (lambda (&rest _)
            (when (and after-init-time
                       (or (daemonp)
                           (and (boundp hook)
                                (symbol-value hook))))
              (run-hooks hook-var)
              (set hook-var nil))))
      (cond ((daemonp)
             (add-hook 'after-init-hook fn 'append))
            ((eq hook 'find-file-hook)
             (advice-add 'after-find-file :before fn '((depth . -101))))
            ((add-hook hook fn -101)))
      fn)))
#+end_src

Then we need to create the hook variables themselves.

#+begin_src emacs-lisp
(defvar init-first-input-hook nil
  "Transient hooks run before the first user input.")
(put 'init-first-input-hook 'permanent-local t)

(defvar init-first-file-hook nil
  "Transient hooks run before the first interactively opened file.")
(put 'init-first-file-hook 'permanent-local t)

(defvar init-first-buffer-hook nil
  "Transient hooks run before the first interactively opened buffer.")
(put 'init-first-buffer-hook 'permanent-local t)
#+end_src

Finally, we can schedule each of these to go off at the proper time.

#+begin_src emacs-lisp
(unless noninteractive
  (init-run-hook-on 'init-first-buffer-hook '(find-file-hook window-buffer-change-functions))
  (init-run-hook-on 'init-first-file-hook '(find-file-hook dired-initial-position-hook))
  (init-run-hook-on 'init-first-input-hook '(pre-command-hook)))
#+end_src

* XDG Directories

I want to save files in places that make sense with the XDG
specification, but I also want to use locations that make sense on
Windows.

First define locations to pick the right folder based on the
environment:

#+begin_src emacs-lisp
;; Config Directories
(require 'xdg)
(defun init-data-home ()
  "Find the directory for user specific data files."
  (expand-file-name
   "emacs"
   (if IS-WINDOWS
       (getenv "APPDATA")
     (xdg-data-home))))

(defun init-state-home ()
  "Find the directory for user specific data files.

This directory is for files less portable or less important than
the ones in `init-data-home'."
  (expand-file-name
   "emacs"
   (if IS-WINDOWS
       (getenv "LOCALAPPDATA")
     (xdg--dir-home "XDG_STATE_HOME" "~/.local/state"))))

(defun init-cache-home ()
  "Find the directory for user specific cache files."
  (expand-file-name
   "emacs"
   (if IS-WINDOWS
       (getenv "LOCALAPPDATA")
     (xdg-cache-home))))
#+end_src

Next, I define some convenients functions to build paths to these
standard locations.

#+begin_src emacs-lisp
(require 'cl-lib)
(defun init-path (&rest segments)
  "Assemble SEGMENTS into a complete path string."
  (cl-reduce (lambda (acc segment)
               (expand-file-name segment acc))
             segments))

(defun init-data-path (&rest segments)
  "Assemble SEGMENTS into a path relative to `init-data-home'."
  (apply #'init-path (init-data-home) segments))

(defun init-state-path (&rest segments)
  "Assemble SEGMENTS into a path relative to `init-state-home'."
  (apply #'init-path (init-state-home) segments))

(defun init-cache-path (&rest segments)
  "Assemble SEGMENTS into a path relative to `init-cache-home'."
  (apply #'init-path (init-cache-home) segments))
#+end_src

* Package Management

I want to try to use built in packages where-ever reasonable and to
initialize external packages in a lazy way.

I need a function to initialize straight when I need it:
#+begin_src emacs-lisp
(eval-when-compile
  (defvar straight-base-dir)
  (defvar straight-use-package-by-default))
(defun init-ensure-straight ()
  "Ensure that straight is installed."
  (unless (featurep 'init-straight)
    (setq straight-base-dir (init-state-path)
          straight-use-package-by-default t)
    (let ((bootstrap-file
           (init-state-path "straight" "repos" "straight.el" "bootstrap.el")))
      (unless (file-exists-p bootstrap-file)
        (with-current-buffer
            (url-retrieve-synchronously
             "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
             'silent 'inhibit-cookies)
          (goto-char (point-max))
          (eval-print-last-sexp)))
      (load bootstrap-file nil 'nomessage)
      (provide 'init-straight))))
#+end_src

Then I'll need a function to install a package when I need to:
#+begin_src emacs-lisp
(eval-when-compile
  (defun straight-use-package (&rest _)))
(defun init-ensure-package (package)
  "Install PACKAGE if necessary."
  (init-ensure-straight)
  (straight-use-package package))
#+end_src

* Core Emacs Configuration
** Startup UI

#+begin_src emacs-lisp
(setq-default
 inhibit-startup-screen t
 inhibit-startup-message t
 inhibit-startup-echo-area-message t
 initial-scratch-message ""
 initial-buffer-choice t)
#+end_src

** Encoding

#+begin_src emacs-lisp
(require 'seq)
(seq-doseq (fn '(set-default-coding-systems
                 prefer-coding-system
                 set-terminal-coding-system
                 set-keyboard-coding-system
                 set-buffer-file-coding-system
                 set-selection-coding-system))
  (apply fn (list (if IS-WINDOWS
                      'utf-8-dos
                    'utf-8-unix))))
(set-language-environment "English")
#+end_src

** Recovery

#+begin_src emacs-lisp
(setq auto-save-list-file-prefix
      (file-name-as-directory
       (init-cache-path "autosave")))

(setq auto-save-default t
      auto-save-timeout 20
      auto-save-interval 200)
#+end_src

** Backups

#+begin_src emacs-lisp
(setq backup-directory-alist
      `(("." . ,(init-cache-path "backups"))))

(setq make-backup-files t
      vc-make-backup-files nil
      backup-by-copying t
      version-control t
      kept-old-versions 6
      kept-new-versions 9
      delete-by-moving-to-trash t)
#+end_src

** Bookmarks

#+begin_src emacs-lisp
(eval-when-compile
    (defvar bookmark-default-file))
(eval-after-load 'bookmark
  (setq bookmark-default-file
        (init-cache-path "bookmark")))
#+end_src

** Recent Files

#+begin_src emacs-lisp
;; Recentf
(eval-when-compile
  (defvar recentf-max-menu-items))
(eval-after-load 'recentf
  (setq recentf-max-menu-items 50))
(add-hook 'init-first-file-hook #'recentf-mode)
#+end_src

** Save History
#+begin_src emacs-lisp
;; https://emacs.stackexchange.com/questions/4187/strip-text-properties-in-savehist
(defun unpropertize-kill-ring ()
  "Remove properties from `kill-ring'."
  (setq kill-ring (mapcar 'substring-no-properties kill-ring)))
(add-hook 'kill-emacs-hook 'unpropertize-kill-ring)

(eval-when-compile
  (defvar savehist-additional-variables))
(eval-after-load 'savehist
  (progn
    (setq kill-ring-max 50
          history-length 50)
    (setq savehist-additional-variables
          '(kill-ring
            command-history
            set-variable-value-history
            query-replace-history
            read-expression-history
            minibuffer-history
            read-char-history
            face-name-history
            bookmark-history
            file-name-history))
    (put 'minibuffer-history 'history-length 50)
    (put 'file-name-history 'history-length 50)
    (put 'set-variable-value-history 'history-length 25)
    (put 'query-replace-history 'history-length 25)
    (put 'read-expression-history 'history-length 25)
    (put 'read-char-history 'history-length 25)
    (put 'face-name-history 'history-length 25)
    (put 'bookmark-history 'history-length 25)
    (setq history-delete-duplicates t)))
(add-hook 'init-first-input-hook #'savehist-mode)
#+end_src

** Save Place in File
#+begin_src emacs-lisp
(eval-when-compile
  (defvar save-place-file)
  (defvar save-place-forget-unreadable-files))
(eval-after-load 'saveplace
  (setq save-place-file (init-cache-path "saveplace")
        save-place-forget-unreadable-files t))
(add-hook 'init-first-input-hook #'save-place-mode)
#+end_src

** Start Server
#+begin_src emacs-lisp
(require 'server)
(unless (server-running-p)
  (server-start))
#+end_src

* Emacs UI

#+begin_src emacs-lisp
  (defun init-font-exists-p (font-name)
    "Returns `t' if FONT-NAME is a valid font family."
    (member font-name (font-family-list)))

  (defun init-find-font ()
    (cond ((init-font-exists-p "Fira Code")
	   (font-spec :family "Fira Code" :size 18))
	  (t nil)))

  (defun init-variable-pitch-font ()
    (cond ((init-font-exists-p "Fira Sans")
	   (font-spec :family "Fira Sans" :size 18))
	  (t nil)))

  (defvar init-font (init-find-font)
    "The default font to use.

  Inspired by the way Doom Emacs handles `doom-font'.")

  (defvar init-variable-pitch-font (init-variable-pitch-font))
  (defvar init-serif-font nil)

  (defun init-load-fonts ()
    "Loads `init-font'."
    (dolist (pair `((default . ,init-font)
		    (fixed-pitch . ,init-font)
		    (fixed-pitch-serif . ,init-serif-font)
		    (variable-pitch . ,init-variable-pitch-font)))
      (when-let* ((face (car pair))
		  (font (cdr pair)))
	  (set-face-attribute face nil
			    :width 'normal :weight 'normal
			    :slant 'normal :font font))))
  (add-hook 'init-first-buffer-hook
	    #'init-load-fonts)

  (setq hscroll-margin 2
	hscroll-step 1
	scroll-conservatively 101
	scroll-margin 0
	scroll-preserve-screen-position t
	auto-window-vscroll nil
	mouse-wheel-scroll-amount '(2 ((shift) . hscroll))
	mouse-wheel-scroll-amount-horizontal 2)

  (blink-cursor-mode -1)
  (setq x-stretch-cursor nil)

  (setq indicate-buffer-boundaries nil
	indicate-empty-lines nil)

  (setq frame-resize-pixelwise t)

  (setq window-resize-pixelwise nil)

  ;; Doom says this is faster than calling the corresponding functions. See
  ;; core-ui.el
  (push '(menu-bar-lines . 0)   default-frame-alist)
  (push '(tool-bar-lines . 0)   default-frame-alist)
  (push '(vertical-scroll-bars) default-frame-alist)

  (setq window-divider-default-places t
	window-divider-default-bottom-width 1
	window-divider-default-right-width 1)

  (add-hook 'init-first-buffer-hook
	    #'window-divider-mode)

  ;; Avoid inconsistent GUIs
  (setq use-dialog-box nil)
  (when (bound-and-true-p tooltip-mode)
    (tooltip-mode -1))
  (when IS-LINUX
    (setq x-gtk-use-system-tooltips nil))

  (setq split-width-threshold 160
	split-height-threshold nil)

  (setq enable-recursive-minibuffers t)
  (setq echo-keystrokes 0.02)
  (setq resize-mini-windows 'grow-only)
  (advice-add #'yes-or-no-p :override #'y-or-n-p)

  (setq minibuffer-prompt-properties '(read-only t intangible t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
#+end_src

* Lisp

#+begin_src emacs-lisp
(add-hook 'emacs-lisp-mode-hook
	  (lambda ()
	    (init-ensure-package 'lispy)
	    (lispy-mode)))
#+end_src

* Show Benchmarking

#+begin_src emacs-lisp
(let ((init-time (float-time (time-subtract (current-time) init-start-time)))
      (total-time (string-to-number (emacs-init-time "%f"))))
  (message "Initialization time %.2fs (+ %.2f system time)"
           init-time (- total-time init-time)))
#+end_src

* Finalize
#+begin_src emacs-lisp
(provide 'init)
;;; init.el ends here
#+end_src
