Title: Intro to Effect Rx | #6 Building an App with Effect - YouTube

Okay, so I was going to show you guys
how to integrate Kiselli, but after some
consideration, we're sticking with
effects SQL client. And the reasoning is
twofold. The first, DBMSS are incredibly
powerful nowadays. There's just so much
you can do with Rasql that OMS and even
query builders can't feasibly support.
And second, we're not really worried
about compile time safety. Why? because
our integration tests will catch any
issues. So we're getting runtime safety
which is obviously more representative
of a realworld scenario. So we're
keeping it simple and universal by
sticking with SQL. So today we're going
to work on integrating our styles RPC
live with the client. So we're going to
use effect RX for that. So first things
first, we're going to come here to the
client and we're going to come here to
the root of the application and here
we're going to add the registry for
effects. So think of it like tan stock
query client. So we already have the
library installed. So we can say
registry provider and we wrap everything
up here. So once you have this provider
logically any consumer down this tree
will use this globally provided registry
which would be the RX client. So if we
take a look at the internals it uses
registry.make
to which we can configure via props. So
perfect with this we can now create our
API client service. So here under
services and then common we're going to
create a file called API client.ts
and we're going to export a class which
will be API client extends effect and
then service and let's prefix the tag
with at or just to make sure there are
no potential collisions and then we're
going to require something. So for now
empty dependencies and here we're going
to return an object which will expose an
HTTP property and here we're going to
say yield HTTP client and then make and
then we're going to pass in our domain
API and then for the options we can pass
in the base URL the transform client and
the transform response. So this already
internally uses the HTTP client for us.
So we do not have to define it from
scratch. So for base URL we can say
embarrass and then API URL and then for
the transform client we're going to add
some retries. So pipe http client and
then retry transient and then for the
options let's do it a total of three
times and for the schedule an
exponential schedule starting at 100
millles with a factor of two which I'm
not sure if it's the default it is. So
we can omit this and that's pretty much
it. Now this means API client will
require the implementation for the HTTP
client. So we can say fetch HTTP client
layer from artifact platform. And if we
take a look again as we can see it will
not require anything. Great. Now my
recommendation is always use scoped
instead of effect when creating your
services using effect.service service
just to make sure that if you later down
the road or whatever require a scope
then you don't need to do anything and
they believe this will change for effect
v4 so for the next major release where
they won't have the notion of effect or
scoped it will be effect which will
already exclude the scope for you but
don't quote me on that I may be mistaken
so now let's create here at the top
level a directory called RX. And here
we're going to have our RX runtime.ts
or maybe just runtime.ts.
And here we're going to need two things.
We're going to have a managed runtime.
So if you need to run something outside
of the context of a Rex, you can do so.
And we need a runtime factory for our
access so we can share the same service
instances to avoid duplicating
construction which isn't something you
would ever want. So for this we can see
export const runtime is equal to manage
runtime and we must pass in a layer. So
main layer is layer mergel and here we
need the API client we need the network
monitor and we need the worker client so
default and we can pass it here to make
and we also need some logger configs so
we can say layerprovide
we can actually merge this so we can say
logger pretty so now Everyone gets
access to this pretty logger and then
provide merge the logger dot minimum log
level and then mbars do effective m is
equal to dev if so log level debug else
log levelinfo
now I'm not a fan of this pretty logger
for the front end or the back end it's
fine but for the front end I don't like
the annotations and how it collapses the
logs in the console and whatnot. So
later down the road, I'm going to show
you how to extend this logger and how we
can create a a nicer logger for the
client. So with this, we are halfway
there. However, I'm not sure if managed
runtime make logs any defects or errors
that occur on layer construction. So as
we can see, it does to runtime with memo
map. But there doesn't seem to be any
logs. So let's do log. Yeah, no logs. So
for that I assume we would need to log
the errors. So we can say layer tap
error cause and then effect.log error.
And for some reason this is not
importing. Okay, great. So now we need
our RX runtime. So for that we can
create a global RX runtime which would
be RX and then runtime and then we
invoke this and pass in the main layer.
But this is problematic because we would
be constructing main layer twice. So if
you were to set up some resources and
whatnot then you're going to get
everything duplicated which is not what
you want. So in that case we can share a
memo map. So we can say const memo mapap
is equal to effect.r of run sync and
then layer make memo map. And as we can
see we get back a layer memo map. And so
we can pass in the memo map to manage
the runtime. And instead of doing it
here or RX runtime, we can export an RX
runtime factory or maybe a make RX
runtime and then this would be RX dot
and then context and then you would pass
in the memo map and this will give you
back a function. So you can say make our
Rex runtime and you pass in the main
layer. That way again you can share the
same services but expand on them however
you want. Ultimately it is going to use
the same memo map under the hood. So
what is a memo map? Well a memo map is a
concurrent cache that prevents
rebuilding the same layer multiple
times. So it stores the layer
construction results and shares them
across fibers with the proper cleanup.
And this is what effect uses under the
hood. It by default creates its own memo
map. And when you say for example here
at server layer.launch and then run this
well this is going to use under the hood
a default memo map to ensure that it
caches layer construction results which
is by reference if I'm not mistaken. Now
there's one thing to note and that is
the layers will not be initialized
unless you actually run something. So
what I mean by this is if I were to come
here to the worker client and were to
yield an effect log worker client and
save this and then come back to my
browser tab and then to the console
you'll see there's no log. And if I
refresh nothing so it doesn't construct
everything eagerly. It constructs the
layers once you actually execute
something. That means that you can come
here and for example at the root create
a new file like init runtime and then
you export a component in it runtime and
then you return null and then you say
react use effect and here you do runtime
from RX runtime and then run sync and
then effect. Succeed.
And if we come back here to the root and
then add the component here, you will
notice that we get worker started and we
also get worker client. Then notice how
we're getting fiber failures because
we're running effects that are
asynchronous in a synchronous manner.
And that's because the construction of
the services are also tied to this
runner. So when you run this, this will
pause execution for this effect and will
only actually execute this effect once
the layers have been constructed. And we
can confirm this by doing uh effect log
and then init runtime. And this should
come at the very end. So if I save this
and then refresh, you'll see that we get
in it runtime. So here we can replace
this with a run call back where this is
going to return to us a function that
when invoked will interrupt the fiber
that it is executing. So this is really
nice as you can directly return this and
so when the use effect cleanup function
is called the fiber will be interrupted.
And if I save this and then refresh, as
we can see, we get no errors at all. So,
as you can see, this is a really
powerful primitive because that means
you can tie life cycle of services in
effect directly to your React
components. So for example, if you have
a sub tree or authenticated users, then
you can construct layers only when that
sub tree is rendered, which makes it
really nice as you can dispose of the
runtime on on unmount. So you can run
finalizers and whatnot. And even in this
case, you can do HTTP requests and you
can use run call back and that will
interrupt the request if the user for
example navigates away or closes a
dialogue whatever. However, we're not
going to have this in it runtime. And
the reason is because we're going to let
Rex do it. So we're going to have soon
enough an SSC arx that will establish
that long lived connection and whatnot
and that will be mounted at the very
root of the whole application tree which
means that that Rex will be responsible
for constructing the services. So no
need to have an init runtime. So now
what we're going to do is create a
features directory. And here we're
basically going to mirror what's here
under routes. And the reason is because
T stand router doesn't let you collocate
files otherwise they will all be treated
as routes. So we're going to have an
index and here we'll have an
index.page.tsx.
And now we're going to export index page
react.fc
and for now return null and we're going
to create a data access directory. Now I
would normally colllocated within the
future but this is a very small
application. So I don't think the
maindriven development is worth it at
least not in the strict sense. So here
we're going to have a styles RX file and
this will export a styles RX which is RX
runtime that will provide the services
and here we're going to say RX and then
we can say effect function and here we
can get access to this get which is an
RX context but we'll see what that means
in a moment and here we're going to get
access to the API. So API client and
then return yield API.httpstyles
and then list and if we take a look at
styles arx ignoring this error we can
see that it is an arx of a result and
this result will succeed with a read
only array of style and will fail with
these different errors. So what is anx?
Well, an RX is a reactive computation
node. So, it basically represents a
value that can change over time and thus
any subscriber will be updated when it
changes. So, when we do this RX runtime
and then pass in this create function,
we're basically creating a unique node
whose computation will not start until
first access. So as we have seen unless
there's a consumer this will not be
executed. So with this we can now come
here to our index page and then access
the result. So yield or to much effect
use RX value and then styles RX and this
will give us only the value no setter
the this is like a use query. So if you
have used tan query you can basically
treat this as a use query it's not quite
the same for example what about input
variables what about eing references to
multiple sub queries under a parent one
so for example styles by idea rex you
can't just define an input parameter
here but in essence it is basically a
use query though way more powerful since
it can work with synchronous state which
we'll see in a moment. So with this we
have now subscribed again to this RX and
when this RX changes this component and
any dependence will be rerendered
logically. So now let's do a
JSON.stringify
styles result and then let's add some
formatting. And if we refresh, we're not
getting anything because I forgot to um
here under routes and then index and
then replace the component with the
index page component. And now if we come
back and then refresh, still not
working. So what am I doing wrong? Could
it be the root component, not the index?
Well, seems like it is. Let's replace
this with the index page.
And as we can see, we get the RX and
then we get some course errors which we
need to resolve. But it works. So it is
actually doing the request. So I guess I
need to revise the tan router
documentation. But I guess this index
route doesn't do anything. So we can get
rid of it and rename this with root. and
then root page and same with the
component name. Great. So now as we can
see here we get underscore tag failure
and then we get the cause and then we
have this waiting boolean property. So
if we come here to styles result as we
can see we only get access to these two
properties because it's all a
discriminated union. So depending on the
tag you can access other properties but
one common property is waiting. So this
tells you if it is still executing that
async computation. However, not to be
confused with tan queries is loading. Is
loading is only for the initial request.
So if you were to just check waiting
this would be the equivalent of is
fetching. So doesn't matter if it's the
first time fetching something. If you
want is loading then you can say styles
result tag is equal to initial and it's
waiting. So this is loading and this is
is fetching. Anyway let's try narrowing
the other tags. So tag and then success.
If we do this we get access to a value
property. And as we can see this value
property will be the array of styles.
And if we were to do failure we get
access to the cause. And this cause is
an effect cause to which you can check
cause is failure etc etc to narrow down
the different failure types. And that's
pretty much it. So, as you can see, it's
super straightforward, very, very
similar to tan query, at least in the
capabilities, though I would argue it is
a step up. Anyway, what about Rexs that
aren't a sync? How does that work? Well,
same thing. Let's do sync RX and then RX
runtime. RX. And here, instead of
returning an effect, let's return null.
However, we're going to get a type
error. And why is that? Well, if you
take a look at the signature of a Rex,
you'll see that all overloads expect
either an effect or a stream. And that
makes sense. If you are using a Rex
runtime, then that's because you want to
access services that the runtime
provides. So, for synchronous state, why
would you use Rex runtime? In that case
you can use the core module. So a rex
and then you can say make and here this
one will take a ton of overloads as you
can see a function and you must return
an effect or just the effect directly
etc. But here at the very end we have
these two overloads. So we can either
pass in a function that gives us the
context and we return a so for
synchronous operations or you can simply
pass in an initial value right away
without the function. So if we do that
and we say null we'll see that this is